'''
Class representing an (encoder, decoder)-pair.
'''

class Expert():

    '''
    Fields
    '''
    self.model_path = None
    self.train_triplets = None
    self.valid_triplets = None
    self.test_triplets = None
    self.entity_count = None
    self.relation_count = None
    
    '''
    Initialization. Requires Encoder, Decoder, and Auxilliaries class.
    '''

    def __init__(self, encoder, decoder, auxilliaries):
        self.encoder = encoder
        self.decoder = decoder
        self.auxilliaries = auxilliaries

        
    '''
    Methods for setting up train and test processes:
    '''

    def set_model_path(self, model_path):
        self.model_path = model_path

    def preprocess(self, train_triplets, valid_triplets, test_triplets):
        self.train_triplets = train_triplets
        self.valid_triplets = valid_triplets
        self.test_triplets = test_triplets 

    def set_entity_count(self, count):
        self.n_entities = count

    def set_relation_count(self, count):
        self.n_relations = count

    def initialize_train(self):
        self.encoder.initialize_train()
        self.decoder.initialize_train()

    def initialize_test(self):
        self.encoder.initialize_test()
        self.decoder.initialize_test()

        
    '''
    Methods to return handles for weights and input.
    '''

    def get_train_input_variables(self):
        pass

    def get_test_input_variables(self):
        pass

    def get_weights(self):
        pass

    def assign_weights(self, weights):
        pass
    
    '''
    Call on components to compute a train-time loss for optimization. 
    Includes e.g. dropouts and regularization.
    '''

    def calculate_train_loss(self):
        vertex_embeddings = self.encoder.encode_vertices(training=True)
        relation_embeddings = self.encoder.encode_relations(training=True)
        regularization = self.encoder.get_regularization()

        predictions = self.decoder.decode(vertex_embeddings, relation_embeddings)
        regularization += self.decoder.regularization()

        return self.auxilliaries.loss(predictions, regularization=regularization)

    
    '''
    Methods for quickly scoring all triples with respectively subject and object replaced:
    '''

    def score_all_subjects(self, triples):
        pass

    def score_all_objects(self, triples):
        pass

    
    
    '''
    Model persistence methods:
    '''
    
    def save(self, filename):
        store_package = self.auxilliaries.process_weights(self.get_weights())
        
        store_package += [self.entity_count,
                          self.relation_count]

        store_file = open(filename, 'wb')
        pickle.dump(store_package, store_file)
        store_file.close()

    def load(self, filename):
        pass
